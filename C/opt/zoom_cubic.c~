#include "opt.h"

//minimize a quadtratic interpolant
static inline double min_quadratic(double a1,double f0,double g0,double f1)
{
	return -(g0*a1*a1)/(2.0*(f1-f0-g0*a1));
}

//minimize a cubic interpolant
static inline double min_cubic(double a1,double a2,double f0,double g0,double f1,double f2)
{
	double a1_sqr=a1*a1,a2_sqr=a2*a2,fac,d1=f2-f0-g0*a2,d2=f1-f0-g0*a1,a,b;
	fac=1.0/(a1_sqr*a2_sqr*(a2-a1));
	a=fac*(a1_sqr*d1-a2_sqr*d2);
	b=fac*(a2*a2_sqr*d2-a1*a1_sqr*d1);
	return (-b+sqrt(b*b-3.0*a*g0))/(3.0*a);	
}

/*
"zoom" function that minimizes an objective function f along a direction p within
some bracket [a1,a2] by approximating f with a quadratic or cubic polynomial.
*/
double zoom_cubic(int n,const double*x0,double a_low,double a_hi,double f0,double f1,double g0,const OBJ_FUNC f,const GRAD_FUNC g,const double*p,void *data)
{
	//check inputs
	if(!(f&&g&&p))return -1.0;
	
	//initialize variables
	int n_iters=0;
	double al=a_low,ah=a_hi,fl=f0,fh=f1,fi,*gl=malloc(n*sizeof(double)),*gh=malloc(n*sizeof(double)),*x=malloc(n*sizeof(double));
	f0=f(n,)
	
	
	
	while(n_iters<MAX_ITERS)
	{
		//evaluate f at new point
		add(n,x0,p,a2,x);
		if(!n_iters)a
		
		n_iters++;
	}
	
	//exit program if we reached max iterations
	if(n_iters==MAX_ITERS)
	{
		printf("Interpolation failed to find an adequate step length in %d iterations. Exiting...\n",MAX_ITERS);
		exit(8);
	}
	
	//free memory and return
	free(g0);
	free(g1);
	free(x);
	return al;
}
